from Crypto.Util.number import inverse, long_to_bytes
import sympy

# Given values
c = 140917890294824041592749185379257631402081513646032716565072591384819342982805856234998429227115969542817522813069669633696083274922990024724877511211737274149952734114878472766991491840816534919528186215575062493208344203914920983866232714888745834728934382554549712877758481770964572110163924684677332272791078714755903143006735021910107862895
n = 152119320786142095281175635806811948875979750638332245172638534404990264774720028015533758955379374996143144735882484881872871793530373431249504507320186364660185344021566187407617190208985835863166862786524194158187654017567522830877661963219406933250306721207073492531142047440331768776002969583714306830935605180674541588682169200767040947363
e = 65537

# Step 1: Factor n
p, q = sympy.factorint(n).keys()  # You can also find p and q using other methods if needed.

# Step 2: Calculate Ï†(n)
phi_n = (p - 1) * (q - 1)

# Step 3: Compute d
d = inverse(e, phi_n)

# Step 4: Decrypt c
m = pow(c, d, n)

# Convert to bytes and decode
flag = long_to_bytes(m).decode()

print(f'Decrypted message: {flag}')
